### Challenge 1: GitOps and AKS
Objective: Understand GitOps. Refer to [A first Workload with Bedrock](https://github.com/microsoft/bedrock/tree/docs_spk/docs/firstWorkload).

Goals:
- Deploy a Bedrock single-key vault cluster
- Deploy the Azure voting app resource manifest

Steps:
- Deploy a kubernetes single key-vault cluster with flux via `spk`
- Clone the `voting-manifest` repo that was created in the previous challenge
- Push the [`azure-vote.yaml`](azure-vote.yaml)(resource manifest file) for the voting app in the `voting-manifest` repository.


### Challenge 1.1: Resource Manifest
Objective: Understand the pros and cons of working with raw resource manifests

Goal: Make a change to the voting app resource manifest. Verify it was automatically deployed via GitOps.

Steps:
- Change the docker image tag for the voting app from `v1` to `v3` in the `azure-vote.yaml`. New image name: `edsa14/azure-vote-front:v2`
- Push the change to the repository

The v3 application should have the title in blue:
![voting app v2](./images/azure-vote-v2.png)


### Challenge 1.2: Helm (optional)
Objective: Generate a resource manifest from a helm chart

Goal: Get a basic understanding of the pros/cons of Helm.

Steps:
- Clone the [repository](https://github.com/edaena/helm-charts) with the helm chart for the azure voting app. 
- `cd helm-charts`
- `helm template ./azure-vote`
- Change the image tag in `values.yaml` to `v3`
- `helm template ./azure-vote`

Verify that the generated resource manifest has the `v2` image tag.


### Challenge 1.3: From Helm to High Level Deployment Definitions
Objective: Generate resource manifests for different environments from an HLD.

Goal: Understand the benefits of using HLDs for large applications for different deployment environments.

Steps:
- Clone the [Azure voting app HLD repository](https://github.com/edaena/azure-vote-hld)
- `fab install`
- `fab generate common`
- `fab generate prod`

Compare the `common` and `prod` manifests.
